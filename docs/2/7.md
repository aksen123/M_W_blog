---
description: 5일차 - useEffect
title: 유데미x스나이퍼팩토리 Next.js 3기 - 사전직무교육 - 5일차(useEffect)
tags:
  [
    유데미,
    udemy,
    웅진씽크빅,
    스나이퍼팩토리,
    인사이드아웃,
    미래내일일경험,
    프로젝트캠프,
    부트캠프,
    React,
    리액트프로젝트,
    프론트엔드개발자양성과정,
    개발자교육과정,
  ]
---

![](./img/image-1.png)

## useEffect 사용법

```tsx
useEffect(
  () => {
    //실행할 함수
  },
  [] //의존성 배열
);
```

<br />

### 의존성 배열

```tsx title='의존성 배열이 빈배열 일때 : 마운트시에 한번만 실행'
useEffect(
  () => {
    //실행할 함수
  },
  [] //의존성 배열
);
```

```tsx title='의존성 배열에 값이 있을때 : 해당값이 업데이트 될 때 마다 실행'
useEffect(
  () => {
    //실행할 함수
  },
  [state] //의존성 배열
);
```

```tsx title='콜백함수에서 함수를 return할 때 : 컴포넌트가 언마운트(삭제) 될 때 return 함수를 실행'
useEffect(() => {
  //실행할 함수
  return () => {}; // 클린업 함수
}, []);
```

<br />

## useLayoutEffect

useEffect() 훅과 똑같은 개념이지만, 실행되는 방식에서 차이가 있다
useEffect() 훅은 화면에 컴포넌트가 렌더링 된 후 비동기적으로 실행됩니다. 그래서 DOM을 조작하는 경우 ‘깜빡임’을 볼 수 있을 확률이 높습니다.

useLayoutEffect()는 화면에 컴포넌트를 그리기 바로 직전에 동기적으로 실행됩니다. 그래서 DOM을 조작하는 경우 ‘깜빡임’을 볼 수 없습니다.

### 주요 특징

- 실행 시점: useLayoutEffect는 모든 DOM이 업데이트된 후 브라우저가 화면에 내용을 그리기 전에 동기적으로 실행됩니다. 반면, useEffect는 렌더링 이후 비동기적으로 실행됩니다. 따라서 useLayoutEffect는 레이아웃이 깨지지 않도록 DOM 조작이 필요한 경우 적합합니다.

- 동기적 실행: useEffect는 비동기적으로 실행되기 때문에 화면이 먼저 업데이트되고 그 이후에 실행됩니다. 하지만 useLayoutEffect는 동기적으로 실행되어, DOM 조작이 끝난 후 바로 적용되므로 사용자가 DOM 변경을 보기 전에 UI가 업데이트될 수 있습니다.

### 주로 사용되는 경우

- 화면에 그려지기 전에 DOM을 직접 조작해야 할 때.
- 스크롤 위치나 사이즈 계산 후 이를 바로 적용해야 할 때.
- CSS나 스타일 변경 후 화면에 즉시 반영해야 할 때.

<br />

## 메모이제이션

컴포넌트의 성능을 최적화하기 위해 불필요한 재렌더링을 방지하는 기법으로 사용한다. 특정 값이나 함수가 변경되자 않는 한 다시 계산되지 않도록 해주는것

### React.memo() : 컴포넌트

순수컴포넌트에서 사용되는 고차컴포넌트로 컴포넌트가 같은 props로 반복해서 렌더링되지 않도록 방지해준다.

- 부모 컴포넌트가 자주 렌더링 되지만 자식 컴포넌트의 props는 변하지 않을 때사용
- props에 동일한 값이 계속 전달되면서 불필요한 재렌터링을 막고 싶을 때

```tsx
import React from "react";

const MyComponent = React.memo(({ name }) => {
  console.log("컴포넌트 렌더링");
  return <div>{name}</div>;
});

function App() {
  return (
    <div>
      <MyComponent name="John" />
      <MyComponent name="John" />
    </div>
  );
}
```

### useCallback() : 함수재생성 방지

React는 기본적으로 컴포넌트가 다시 렌더링 될때마다 내부에서 정의된 함수를 새로 생성하는데, 함수가 props로 들어가게 될 경 값이 변하는것으로 인식해 해당 컴포넌트가 재렌더링 되게 된다. useCallback을 사용하면 의존성 배열에 포함된 값이 변경되지 않는 한 동일한 함수 인스턴스를 반환한다.

- 부모 컴포넌트가 렌더링될 때 자식 컴포넌트에 동일한 콜백 함수가 전달되도록 하고 싶을때
- 콜백 함수가 자식 컴포넌으의 의존성으로 작동할 때 불필요한 재렌더링을 막고 싶을 때

```tsx
const callback = useCallback(() => {}, []);
```

### useMemo(): 특정 값

복잡한 계산을 자주 해야하는 경우에 사용, 값이 변경되지 않는 한 이전에 계산된 결과를 반환하므로 불필요한 계산을 피할 수 있다. 의존성 배열의 값이 변경 되면 첫번째 인자로 전달된 함수가 실행 다시 실행 된다. 만약 배열의 값이 변하지 않으면 이전 계산된 결과를 반환.

컴포넌트가 재렌더링 될 때 마다 내부에 정의된 함수들이 다시 실행되는데 useMemo를 사용하면 재렌더링 될때 의존성 배열의 값이 변하지 않는이상 다시 실행되지 않고 이전의 계산 결과값을 갖고 있는것. 그래서 복잡한 계산을 해야하는경우 useMemo를 사용해주는게 좋다 안그러면 재렌더링 될때마다 복잡한 계산을 다시 해야하기 때문.

- 계산에 시간이 많이 걸리는 작업 (복잡한 연산, 필터링 등)
- 동일한 입력에 대해 반복 계산을 방지하고 싶을 때

```tsx
const memo = useMemo(() => {
  // ~~복잡한 계산 실행
  return; // 콜백함수는 값을 반환해야함
}, []); // 의존성 배열이 빈벼열이면 초기 렌더링시 한번만 실행되고 이후 렌더링이 발생해도 재실행 되지 않음
```

## context api

1. createContext -> 공급자를 생성 ( provider 생성 )
2. 공급 범위를 지정 -> 생성된 공급자로 공급할 컴포넌트를 감싸준다
3. 공급한 데이터를 가져와서 사용한다 -> useContext(context)

<br />
<br />
---

본 후기는 본 후기는 [유데미x스나이퍼팩토리] 프로젝트 캠프 : Next.js 3기 과정(B-log) 리뷰로 작성 되었습니다.

```

```
